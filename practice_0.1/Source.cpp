#include <iostream>

using namespace std;


//Задача - упаковка предметов в контейнеры
//Дано - размер контейнера, размеры и количество предметов
//Нужно найти - минимальное количество контейнеров, в которое поместятся данные предметы и соответствующее размещение

const int N =  10; //количество предметов

int A[N] = { 2, 2, 2, 2, 3, 3, 6, 6, 7, 7}, //размеры предметов

// переменные, используемые в функции
V[N];    //заполненность контейнеров

int Box,  // кол-во контейнеров в текущей упаковке

OptBox,   //кол-во контейнеров в оптимальной упаковке

Cont[N],   //текущая упаковка

OptCont[N];  //оптимальная упаковка (ее как раз надо найти)


// Рекурсивная функция нахождения размещения предметов

void pack(int i)

{
    for (int j = 0; j <= N; j++) { //перебираем контейнеры

        if (V[j] <= 0 && (Box + 1) >= OptBox) break;  // если контейнер j пуст и кол-во контейнеров в текущей упаковке уже превышает оптимальное кол-во, то выходим

        if (j > 0 && V[j - 1] <= 0) break;  //если контейнер не 1 и предыдущий контейнер пустой то выходим

        if (V[j] + A[i] <= 10) { //если заполненость контейнера + размер предмета меньше 10 (т.е туда можно положить предмет), 10 - размер контейнера, можно изменить здесь

            int B = Box;   //в В записываем кол-во кол-во контейнеров в текущей упаковке

            if (V[j] <= 0) Box += 1;  // если пустой, то увеличиваем кол-во контейнеров в этой упаковке на 1

            V[j] += A[i];     //заполняем j контейнер на объем i предмета

            Cont[i] = j;     //предмет i помещаем   в j контейнер

            if (i < N) pack(i + 1);  //если текущий предмет не последний, то вызываем рекурсию и пытаемся упаковать след предмет

            else   //если нет, то

            {

                OptBox = Box;     //в оптим присваиваем текущее кол-во контейнеров в упаковке

                for (int k = 0; k <= N; k++) {
                    OptCont[k] = Cont[k]; //в оптимальную упаковку = текущую упаковку
                }

            }

            Box = B;        //возвращаем старое старое значение контейнеров в упаковке

            Cont[i] = 0;    //выкидываем текущий предмет

            V[j] -= A[i];   //вычитаем объем текущего предмета

        }

    }

}

int main()

{
    for (int i = 0; i < N; i++) {

        V[i] = 0;                    // все контейнеры очищаем

        Cont[i] = 0;                 //все предметы никуда не помещены

        OptCont[i] = i;             // оптимальное кол-во контейнеров в упаковке = N

    }

    OptBox = N;            //пока оптимально поместить каждый предмет в свой контейнер)

    Cont[0] = 0;          //первый предмет упаковываем в 1 вагон

    V[0] = A[0];       // увеличиваем заполненность 1го контейнера на размер 1го предмета

    Box = 1;           //кол-во контейнеров в текущей упаковке =1

    pack(1);          //упаковываем второй предмет

    //Фунция типа void, во время её работы будут изменены OptCont - размещение предметов и OptBox - минимальное количество контейнеров


    for (int i = 0; i < N; i++) {
        cout << "Item with size  " << A[i] << " goes to the box number " << OptCont[i] + 1 << endl;;  //вывод оптимальной упаковки
    }
    cout << endl;
    cout << "You need a total of " << OptBox << " boxes to store these items" << endl; //вывод количества контейнеров
    system("pause");
    return 0;

}